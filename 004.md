nobody2018

high

# attacker corrupts all vaultInfo structure without any DRB tokens locked

## Summary
There is a function called [[mintNewBasket](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L255-L264)] in Game.sol, which user can mint his or her basket NFT. By calling this function the user will mint an NFT on the game contract. By rebalancing this basket, the user can lock DRB tokens and start putting allocations to different protocols. But attacker corrupts **all vault's vaultInfo structure** by minting an nft per vault. **No need to lock any DRB tokens**.
## Vulnerability Detail
Let's assume some variables in the Game contract as following:

- [[chainIds array](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L59)] has two items: chainIds[0]=56, chainIds[1]=137
- [[latestProtocolId mapping](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L77)] has two items: latestProtocolId[56]=1, latestProtocolId[137]=1
- [[vaults map](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L80)] also has two items: vaults[1], vaults[2]

Now attacker start to exploit:

- he calls mintNewBasket(1) and gets an ntf with id 1000.
- he calls [[rebalanceBasket(1000, _deltaAllocations)](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L318-L333)].

```solidity
/*
attacker constructs the second parameter as follows:
        _deltaAllocations[0][0] = -1*e120;
        _deltaAllocations[1][0] =  1*e120;
*/
  function rebalanceBasket(
    uint256 _basketId,
    int256[][] memory _deltaAllocations
  ) external onlyBasketOwner(_basketId) nonReentrant {
    uint256 vaultNumber = baskets[_basketId].vaultNumber;
    for (uint k = 0; k < chainIds.length; k++) {
      require(!isXChainRebalancing[vaultNumber][chainIds[k]], "Game: vault is xChainRebalancing");
    }

    addToTotalRewards(_basketId); //The first line returns inside this function.
    int256 totalDelta = settleDeltaAllocations(_basketId, vaultNumber, _deltaAllocations);//totalDelta = 0

    lockOrUnlockTokens(_basketId, totalDelta); //neither lock nor unlock token due to totalDelta equals to 0
    setBasketTotalAllocatedTokens(_basketId, totalDelta); //no change due to totalDelta equals to 0
    setBasketRebalancingPeriod(_basketId, vaultNumber);	//update lastRebalancingPeriod
  }
```

Why does the [[settleDeltaAllocations](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L342-L364)] function return 0? Let's review its code.

```solidity
function settleDeltaAllocations(
    uint256 _basketId,
    uint256 _vaultNumber,
    int256[][] memory _deltaAllocations	//_deltaAllocations[0][0] = -1*e120, _deltaAllocations[1][0] =  1*e120;
  ) internal returns (int256 totalDelta) {	//totalDelta is a signed number
    for (uint256 i = 0; i < _deltaAllocations.length; i++) {
      int256 chainTotal;
      uint32 chain = chainIds[i];
      uint256 latestProtocol = latestProtocolId[chain];
      require(_deltaAllocations[i].length == latestProtocol, "Invalid allocation length");

      for (uint256 j = 0; j < latestProtocol; j++) {
        int256 allocation = _deltaAllocations[i][j];
        if (allocation == 0) continue;
        chainTotal += allocation;
        addDeltaAllocationProtocol(_vaultNumber, chain, j, allocation);	//it's ok whether the allocation is positive or negative
        setBasketAllocationInProtocol(_basketId, chain, j, allocation); //it's ok whether the allocation is positive or negative
      }

      totalDelta += chainTotal;	//tip:  totalDelta = -1*e120 + 1*e120 = 0
      addDeltaAllocationChain(_vaultNumber, chain, chainTotal);
    }
  }
```

When the function returns, which storage variables are changed?

- vaults[1].deltaAllocationChain[56] += -1e120  (this vaule is a big negative)
    
- vaults[1].deltaAllocationChain[137] += 1e120 (this vaule is a big positive)
    
- vaults[1].deltaAllocationProtocol[56][0] += -1e120  (this vaule is a big negative)
- vaults[1].deltaAllocationProtocol[137][0] += 1e120  (this vaule is a big negative)
## Impact
The cost of this attack is very low, only some gas needs to be paid, and no DRB tokens need to be locked. Attackers can modify the allocation of all vaults, causing the system to allocate funds incorrectly.
## Code Snippet

## Tool used

Manual Review

## Recommendation
We should judge at the beginning of the rebalanceBasket function whether _deltaAllocations exceeds  baskets[_basketId].nrOfAllocatedTokens.

```solidity
function rebalanceBasket(
    uint256 _basketId,
    int256[][] memory _deltaAllocations
  ) external onlyBasketOwner(_basketId) nonReentrant {
    uint256 vaultNumber = baskets[_basketId].vaultNumber;
    for (uint k = 0; k < chainIds.length; k++) {
      require(!isXChainRebalancing[vaultNumber][chainIds[k]], "Game: vault is xChainRebalancing");
    }
    //new code begin
    if (_deltaAllocations.length > 0) {
      int256 nr = basketTotalAllocatedTokens(_basketId);
      if (nr == 0) {
        for (uint256 i = 0; i < _deltaAllocations.length; ++i) {                
          for (uint256 j = 0; j < _deltaAllocations[i].length; ++j) {
            //only positive
            require(_deltaAllocations[i][j] >= 0);
          }
        }
      } else if (nr > 0) {
        int256 negative = 0;
        for (uint256 i = 0; i < _deltaAllocations.length; ++i) {                
          for (uint256 j = 0; j < _deltaAllocations[i].length; ++j) {
            if (_deltaAllocations[i][j] < 0) {
              negative -= _deltaAllocations[i][j];
            }
          }
        }
        require(negative <= nr);
      } else {
        revert();
      }
    }
    //new code end
    addToTotalRewards(_basketId);
    ...
  }
```