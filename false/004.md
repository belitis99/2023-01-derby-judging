nobody2018

high

# Attacker can take away all rewards if lpToken is claimable

## Summary
There is a claim function in **CompoundProvider.sol**. Its declaration is as follows: `function claim(address _cToken, address _claimer) external`. **Without access check**, anyone can call this function to take away all the rewards belonging to the vault.
## Vulnerability Detail
Let's look at [[the code of this function](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/CompoundProvider.sol#L133-L140)]:

```solidity
function claim(address _cToken, address _claimer) external override returns (bool) {	//anyone can call it
    address[] memory cTokens = new address[](1);
    cTokens[0] = _cToken;
    comptroller.claimComp(_claimer, cTokens);

    return true;
  }
```

Normally, this function should be called by the Controller. Let's look at the [[code snippet](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Controller.sol#L57-L70)]:

```solidity
function claim(
    uint256 _vaultNumber,
    uint256 _protocolNumber
  ) external override onlyVault returns (bool) {	//onlyVault can call this function
    if (claimable[protocolInfo[_vaultNumber][_protocolNumber].LPToken]) {
      return
        IProvider(protocolInfo[_vaultNumber][_protocolNumber].provider).claim(	//this is the claim function in provider
          protocolInfo[_vaultNumber][_protocolNumber].LPToken,
          msg.sender
        );
    } else {
      return false;
    }
  }
```

We can see that this is a function that only allows Vault contract calls. Let's look at the [[code snippet of Vault](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L404-L419)]:

```solidity
function claimTokens() public {
    uint256 latestID = controller.latestProtocolId(vaultNumber);
    for (uint i = 0; i < latestID; i++) {
      if (currentAllocations[i] == 0) continue;
      bool claim = controller.claim(vaultNumber, i);	//here
      if (claim) {
        address govToken = controller.getGovToken(vaultNumber, i);
        uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));
        Swap.swapTokensMulti(
          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),
          controller.getUniswapParams(),
          false
        );
      }
    }
  }
```

It is okay to look at the order of these calls in this way, **but attacker can skip the Controller and directly call the Provider's claim**, this is the cause of this issue.
## Impact
This issue is critical. Attacker can take away the rewards generated by all claimable lptokens supported by the protocol. This includes all chains.
## Code Snippet

## Tool used

Manual Review

## Recommendation
Add access check to this function.